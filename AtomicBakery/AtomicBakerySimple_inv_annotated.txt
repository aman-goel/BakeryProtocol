### Proof certificate: #31
##
## target safety property (mutual exclusion)
##
invariant [ic3po_prop1]	(forall Pi, Pj . (~(Pi = Pj) -> (pc_cs(Pi) -> ~pc_cs(Pj))))
##
## auxiliary "one-hot" invariants added to the specification
##
invariant [ic3po_prop7]	(forall P . (pc_p5(P) -> (~pc_p1(P) & ~pc_p2(P) & ~pc_p3(P) & ~pc_p4(P) & ~pc_p6(P) & ~pc_cs(P) & ~pc_p7(P))))
invariant [ic3po_prop6]	(forall P . (pc_p4(P) -> (~pc_p1(P) & ~pc_p2(P) & ~pc_p3(P) & ~pc_p5(P) & ~pc_p6(P) & ~pc_cs(P) & ~pc_p7(P))))
invariant [ic3po_prop4]	(forall P . (pc_p2(P) -> (~pc_p1(P) & ~pc_p3(P) & ~pc_p4(P) & ~pc_p5(P) & ~pc_p6(P) & ~pc_cs(P) & ~pc_p7(P))))
invariant [ic3po_prop9]	(forall P . (pc_p7(P) -> (~pc_p1(P) & ~pc_p2(P) & ~pc_p3(P) & ~pc_p4(P) & ~pc_p5(P) & ~pc_p6(P) & ~pc_cs(P))))
invariant [ic3po_prop8]	(forall P . (pc_p6(P) -> (~pc_p1(P) & ~pc_p2(P) & ~pc_p3(P) & ~pc_p4(P) & ~pc_p5(P) & ~pc_cs(P) & ~pc_p7(P))))
invariant [ic3po_prop10]	(forall P . (pc_p1(P) | pc_p2(P) | pc_p3(P) | pc_p4(P) | pc_p5(P) | pc_p6(P) | pc_cs(P) | pc_p7(P)))
invariant [ic3po_prop2]	(forall P . (pc_cs(P) -> (~pc_p1(P) & ~pc_p2(P) & ~pc_p3(P) & ~pc_p4(P) & ~pc_p5(P) & ~pc_p6(P) & ~pc_p7(P))))
invariant [ic3po_prop3]	(forall P . (pc_p1(P) -> (~pc_p2(P) & ~pc_p3(P) & ~pc_p4(P) & ~pc_p5(P) & ~pc_p6(P) & ~pc_cs(P) & ~pc_p7(P))))
invariant [ic3po_prop5]	(forall P . (pc_p3(P) -> (~pc_p1(P) & ~pc_p2(P) & ~pc_p4(P) & ~pc_p5(P) & ~pc_p6(P) & ~pc_cs(P) & ~pc_p7(P))))
##
## invariants about when ticket numbers are 0
## cf. hand-written invariant:
## \A i \in P : (num[i] = 0) <=> (pc[i] \in {"p1", "p2", "p3"})
## IC3PO only needs the "=>" implication
##
invariant [ic3po_global1_18]	(forall P1 . ((num(P1) = zero_number) -> ~pc_p4(P1)))
invariant [ic3po_other4]	(forall P1 . ((num(P1) = zero_number) -> ~pc_p5(P1)))
invariant [ic3po_other5]	(forall P1 . ((num(P1) = zero_number) -> ~pc_p6(P1)))
invariant [ic3po_other3]	(forall P1 . ((num(P1) = zero_number) -> ~pc_cs(P1)))
##
## invariants about when the flag is set
## cf. hand-written invariant:
## \A i \in P : flag[i] <=> (pc[i] \in {"p2", "p3", "p4"})
## IC3PO only needs the "<=" implication
##
invariant [ic3po_global1_17]	(forall P1 . (pc_p2(P1) -> flag(P1)))
invariant [ic3po_other1]	(forall P1 . (pc_p3(P1) -> flag(P1)))
invariant [ic3po_other2]	(forall P1 . (pc_p4(P1) -> flag(P1)))
##
## invariants about a process at "p6" and the max value of its "nxt" process
## cf. hand-written invariant:
## \A i \in P:
##    /\ (pc[i] = "p6")
##    /\ \/ (pc[nxt[i]] = "p2") /\ (i \notin unread[nxt[i]])
##       \/ pc[nxt[i]] = "p3"
##    => max[nxt[i]] >= num[i]
## IC3PO generates exactly the same invariant
##
invariant [ic3po_other19]	(forall P2, P1 . ((pc_p6(P1) & pc_p2(P2) & nxt(P1, P2)) -> (unread(P2, P1) | le_number(num(P1), max(P2)))))
invariant [ic3po_other15]	(forall P2, P1 . ((pc_p6(P1) & pc_p3(P2) & nxt(P1, P2)) -> le_number(num(P1), max(P2))))
##
## invariants relating a process P1 at "p5" or "p6" and an "unread" process P2
## cf. hand-written invariant:
## \A i \in P : (pc[i] \in {"p5", "p6"}) =>
        \A j \in (P \ unread[i]) \ {i} : After(j, i)
## where After is a multi-line predicate intuitively asserting that process i
## will visit the critical section later than process j.
## The cases when process j is at "p2" or "p3" match exactly.
##
invariant [ic3po_other13]	(forall P2, P1 . ((pc_p5(P1) & pc_p2(P2)) -> (unread(P2, P1) | unread(P1, P2) | le_number(num(P1), max(P2)))))
invariant [ic3po_other9]	(forall P2, P1 . ((pc_p5(P1) & pc_p3(P2)) -> (unread(P1, P2) | le_number(num(P1), max(P2)))))
invariant [ic3po_other14]	(forall P2, P1 . ((pc_p6(P1) & pc_p2(P2)) -> (unread(P1, P2) | le_number(num(P1), max(P2)) | unread(P2, P1))))
invariant [ic3po_other10]	(forall P2, P1 . ((pc_p6(P1) & pc_p3(P2)) -> (unread(P1, P2) | le_number(num(P1), max(P2)))))
##
## The following predicate applies when process j is not at "p1"-"p3"
## (equivalent to assuming ~le_number(num(P2), zero_number)).
## It can be read as asserting
## pc[i] = "p5" /\ j \in (P \ unread[i]) \ {i} /\ pc[j] \in {"p4","p5","p6","cs","p7"}
## => ~ ll(j,i)
## and by totality of the relation ll, the conclusion can be rewritten as ll(i,j).
## This is also implied by the hand-written invariant, except that the latter
## only requires this when pc[j] \in {"p4","p5","p6"}.
## On the other hand, the hand-written has a conjunct about the case where
## both processes i and j are in the range {"p5", "p6"} asserting that
## either of them must be in the "unread" set of the other. This does
## not appear to have a counterpart in the invariant generated by IC3PO.
##
invariant [ic3po_other16]	(forall P2, P1 . ((pc_p5(P1) & ll(P2, P1)) -> (unread(P1, P2) | (P2 = P1) | le_number(num(P2), zero_number))))
##
## Analogous predicate for the case pc[i] = "p6".
##
invariant [ic3po_other17]	(forall P2, P1 . ((pc_p6(P1) & ll(P2, P1)) -> (unread(P1, P2) | (P2 = P1) | le_number(num(P2), zero_number))))
##
## similar invariants for a process at "cs":
## \A i \in P : (pc[i] \in {"cs", "p7"}) => \A j \in P \ {i} : After(j, i)
## Again, the cases when process j is at "p2" or "p3" match exactly.
## IC3PO does not generate the analogous predicates for the case where
## process i is at "p7", which are part of the hand-written invariant.
##
invariant [ic3po_other8]	(forall P2, P1 . ((pc_cs(P1) & pc_p2(P2)) -> (unread(P2, P1) | le_number(num(P1), max(P2)))))
invariant [ic3po_other7]	(forall P2, P1 . ((pc_cs(P1) & pc_p3(P2)) -> le_number(num(P1), max(P2))))
##
## The cases where process j is in the range "p4"-"p7" are again expressed
## similarly as above (when pc[i] \in {"p5","p6"}).
#
invariant [ic3po_other6]	(forall P2, P1 . (pc_cs(P1) -> (ll(P1, P2) | le_number(num(P2), zero_number))))
##
## The following invariants do not appear to correspond directly to anything
## in the hand-written invariant that never compares max[...] to 0.
## The conclusion of the first two predicates resembles the missing bits about one
## process being in the "unread" set of the other, but the conditions are different.
## The last predicate appears to be completely unrelated to anything in the
## hand-written invariant.
##
invariant [ic3po_other11]	(forall P2, P1 . ((pc_p5(P2) & (max(P1) = zero_number) & pc_p4(P1)) -> unread(P2, P1)))
invariant [ic3po_other12]	(forall P2, P1 . (((max(P1) = zero_number) & pc_p4(P1) & pc_p6(P2)) -> unread(P2, P1)))
invariant [ic3po_other18]	(forall P2, P1 . (nxt(P2, P1) -> ((max(P1) = zero_number) -> (pc_p4(P1) -> ~pc_p6(P2)))))
###
