------------------------- MODULE AtomicBakeryIC3PO -------------------------
(***************************************************************************)
(* This module defines a predicate that corresponds to the invariants      *)
(* generated by IC3PO for the atomic version of the Bakery protocol.       *)
(* We then use the TLA+ tools to check its soundness.                      *)
(***************************************************************************)
EXTENDS AtomicBakery

MIInv(i) ==
  /\ pc[i] \in {"p4", "p5", "p6", "cs"} => num[i] # 0
  /\ pc[i] \in {"p2", "p3", "p4"} => flag[i]

  /\ pc[i] \in {"p5", "p6"} => \A j \in P \ unread[i] :
       /\ pc[j] = "p2" => i \in unread[j] \/ max[j] >= num[i]
       /\ pc[j] = "p3" => max[j] >= num[i]
       /\ pc[j] = "p4" => max[j] # 0
       /\ i # j /\ num[j] # 0 => ~ LL(j,i)

  /\ pc[i] = "p6" /\ pc[nxt[i]] = "p2" => i \in unread[nxt[i]] \/ max[nxt[i]] >= num[i]
  /\ pc[i] = "p6" /\ pc[nxt[i]] = "p3" => max[nxt[i]] >= num[i]
  /\ pc[i] = "p6" /\ pc[nxt[i]] = "p4" => max[nxt[i]] # 0

  /\ pc[i] = "cs" => \A j \in P :
       /\ pc[j] = "p2" => i \in unread[j] \/ max[j] >= num[i]
       /\ pc[j] = "p3" => max[j] >= num[i]
       /\ num[j] # 0 => LL(i,j)
       /\ j # i => pc[j] # "cs"

MInv == \A i \in P : MIInv(i)

IndInv == TypeOK /\ MInv

THEOREM Spec => []MutualExclusion
<1>. USE N \in Nat DEFS P, ProcSet, IndInv, TypeOK, MInv
<1>1. Init => IndInv
  BY DEF Init, MIInv
<1>2. IndInv /\ [Next]_vars => IndInv'
  <2> SUFFICES ASSUME IndInv,
                      [Next]_vars
               PROVE  IndInv'
    OBVIOUS
  <2>1. ASSUME NEW self \in P,
               p1(self)
        PROVE  IndInv'
    BY <2>1 DEF p1, MIInv, LL
  <2>2. ASSUME NEW self \in P,
               p2(self)
        PROVE  IndInv'
    BY <2>2, Z3T(30) DEF p2, MIInv, LL
  <2>3. ASSUME NEW self \in P,
               p3(self)
        PROVE  IndInv'
    BY <2>3 DEF p3, MIInv, LL
  <2>4. ASSUME NEW self \in P,
               p4(self)
        PROVE  IndInv'
    BY <2>4 DEF p4, MIInv, LL
  <2>5. ASSUME NEW self \in P,
               p5(self)
        PROVE  IndInv'
    BY <2>5, Z3T(60) DEF p5, MIInv, LL
  <2>6. ASSUME NEW self \in P,
               p6(self)
        PROVE  IndInv'
    BY <2>6 DEF p6, MIInv, LL
  <2>7. ASSUME NEW self \in P,
               cs(self)
        PROVE  IndInv'
    BY <2>7 DEF cs, MIInv, LL
  <2>8. ASSUME NEW self \in P,
               p7(self)
        PROVE  IndInv'
    BY <2>8 DEF p7, MIInv, LL
  <2>9. CASE UNCHANGED vars
    BY <2>9 DEF vars, MIInv, LL
  <2>10. QED
    BY <2>1, <2>2, <2>3, <2>4, <2>5, <2>6, <2>7, <2>8, <2>9 DEF Next, p
<1>3. IndInv => MutualExclusion
  BY DEF MIInv, MutualExclusion
<1>. QED  BY <1>1, <1>2, <1>3, PTL DEF Spec

=============================================================================
