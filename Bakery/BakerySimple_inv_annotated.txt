### Proof certificate: #43
##
## target safety property (mutual exclusion)
invariant [ic3po_prop1]	(forall Pi, Pj . (~(Pi = Pj) -> (pc_cs(Pi) -> ~pc_cs(Pj))))
##
## auxiliary "one-hot" invariants added to the specification
##
invariant [ic3po_prop10]	(forall P . (pc_p1(P) | pc_p2(P) | pc_p3(P) | pc_p4(P) | pc_p5(P) | pc_p6(P) | pc_cs(P) | pc_p7(P)))
invariant [ic3po_prop3]	(forall P . (pc_p1(P) -> (~pc_p2(P) & ~pc_p3(P) & ~pc_p4(P) & ~pc_p5(P) & ~pc_p6(P) & ~pc_cs(P) & ~pc_p7(P))))
invariant [ic3po_prop4]	(forall P . (pc_p2(P) -> (~pc_p1(P) & ~pc_p3(P) & ~pc_p4(P) & ~pc_p5(P) & ~pc_p6(P) & ~pc_cs(P) & ~pc_p7(P))))
invariant [ic3po_prop5]	(forall P . (pc_p3(P) -> (~pc_p1(P) & ~pc_p2(P) & ~pc_p4(P) & ~pc_p5(P) & ~pc_p6(P) & ~pc_cs(P) & ~pc_p7(P))))
invariant [ic3po_prop6]	(forall P . (pc_p4(P) -> (~pc_p1(P) & ~pc_p2(P) & ~pc_p3(P) & ~pc_p5(P) & ~pc_p6(P) & ~pc_cs(P) & ~pc_p7(P))))
invariant [ic3po_prop7]	(forall P . (pc_p5(P) -> (~pc_p1(P) & ~pc_p2(P) & ~pc_p3(P) & ~pc_p4(P) & ~pc_p6(P) & ~pc_cs(P) & ~pc_p7(P))))
invariant [ic3po_prop8]	(forall P . (pc_p6(P) -> (~pc_p1(P) & ~pc_p2(P) & ~pc_p3(P) & ~pc_p4(P) & ~pc_p5(P) & ~pc_cs(P) & ~pc_p7(P))))
invariant [ic3po_prop2]	(forall P . (pc_cs(P) -> (~pc_p1(P) & ~pc_p2(P) & ~pc_p3(P) & ~pc_p4(P) & ~pc_p5(P) & ~pc_p6(P) & ~pc_p7(P))))
invariant [ic3po_prop9]	(forall P . (pc_p7(P) -> (~pc_p1(P) & ~pc_p2(P) & ~pc_p3(P) & ~pc_p4(P) & ~pc_p5(P) & ~pc_p6(P) & ~pc_cs(P))))
##
## invariants about ticket number zero
## cf. hand-written invariant:
## \A i \in P :
##    /\ pc[i] \in {"p1", "p2"} => num[i] = 0
##    /\ num[i] = 0 => pc[i] \in {"p1", "p2", "p3", "p7"}
## IC3PO only needs the second conjunct
invariant [ic3po_global1_11]	(forall P1 . ((num(P1) = zero_number) -> ~pc_p4(P1)))
invariant [ic3po_other3]	(forall P1 . ((num(P1) = zero_number) -> ~pc_p5(P1)))
invariant [ic3po_other4]	(forall P1 . ((num(P1) = zero_number) -> ~pc_p6(P1)))
invariant [ic3po_other2]	(forall P1 . (pc_cs(P1) -> ~(num(P1) = zero_number)))
##
## invariants about when the flag is set
## cf. hand-written invariant:
## \A i \in P:
##    /\ flag[i] => pc[i] \in {"p1", "p2", "p3", "p4"}
##    /\ pc[i] \in {"p2", "p3"} => flag[i]
## IC3PO generates the invariants corresponding to the second conjunct
## but includes the flag predicate in many other invariants.
## It also generates invariants about cases that are excluded according
## to the first conjunct of the hand-written invariant.
invariant [ic3po_global1_23]	(forall P1 . (pc_p2(P1) -> flag(P1)))
invariant [ic3po_other1]	(forall P1 . (pc_p3(P1) -> flag(P1)))
   # The following invariants correspond to impossible cases since the
   # flag cannot be true at "p5" or "p6".
invariant [ic3po_other24]	(forall P1, P2 . ((pc_p5(P2) & flag(P1) & pc_p5(P1)) -> ((P2 = P1) | unread(P2, P1))))
invariant [ic3po_other20]	(forall P1, P2 . ((pc_p6(P2) & flag(P1) & pc_p5(P1)) -> unread(P2, P1)))
invariant [ic3po_other26]	(forall P1, P2 . (pc_p6(P2) -> (flag(P1) -> (nxt(P2, P1) -> ~pc_p5(P1)))))
invariant [ic3po_other28]	(forall P1, P2 . ((pc_p6(P2) & flag(P1) & nxt(P2, P1) & pc_p6(P1)) -> (P2 = P1)))
invariant [ic3po_other30]	(forall P1, P2, P3 . ((flag(P3) & nxt(P2, P1) & pc_cs(P2) & pc_p5(P3)) -> ((P3 = P1) | (P1 = P2))))
invariant [ic3po_other21]	(forall P1, P2 . ((pc_p6(P1) & pc_p5(P2) & flag(P1)) -> unread(P2, P1)))
invariant [ic3po_other25]	(forall P1, P2 . ((pc_p6(P2) & pc_p6(P1) & flag(P1)) -> ((P2 = P1) | unread(P2, P1))))
invariant [ic3po_other31]	(forall P1, P2, P3 . ((flag(P3) & nxt(P2, P1) & pc_cs(P2) & pc_p6(P3)) -> ((P3 = P1) | (P1 = P2))))
##
## invariants about a process at "p6" and the max value of its "nxt" process
## cf. hand-written invariant:
## \A i \in P:
##    /\ pc[i] = "p6"
##    /\ \/ pc[nxt[i]] = "p2" /\ i \notin unread[nxt[i]]
##       \/ pc[nxt[i]] = "p3"
##    => max[nxt[i]] >= num[i]
## IC3PO generates (essentially) the same invariant.
invariant [ic3po_other27]	(forall P1, P2 . ((pc_p6(P2) & pc_p2(P1) & nxt(P2, P1)) -> (unread(P1, P2) | le_number(num(P2), max(P1)))))
invariant [ic3po_other29]	(forall P1, P2 . ((pc_p6(P2) & pc_p3(P1) & nxt(P2, P1) & flag(P1)) -> le_number(num(P2), max(P1))))
    # NB: condition flag(P1) is redundant by [ic3po_other1]
##
## invariants relating a process at "p5" or "p6" and an "unread" process
## cf. hand-written invariant:
## \A i \in P:
##    pc[i] \in {"p5", "p6"} =>
##      \A j \in (P \ unread[i]) \ {i} : After(j,i)
## where "After" is a multi-line predicate defined by case analysis on the pc
## value of process j that intuitively asserts that process i will visit the
## critical section later than process j.
## The invariants generated by IC3PO are essentially the same.
## The only missing assertions are those concerning both processes being
## at {"p5", "p6"}: then at least one process must be in the "unread" set
## of the other one. This is expressed above for the cases where the flag is
## set (which is actually impossible).
invariant [ic3po_other22]	(forall P1, P2 . ((pc_p5(P2) & pc_p2(P1)) -> (unread(P2, P1) | le_number(num(P2), max(P1)) | unread(P1, P2))))
invariant [ic3po_other18]	(forall P1, P2 . ((pc_p5(P1) & pc_p3(P2)) -> (unread(P1, P2) | le_number(num(P1), max(P2)))))
invariant [ic3po_other11]	(forall P1, P2 . ((pc_p5(P1) & pc_p4(P2)) -> (ll(P1, P2) | unread(P1, P2))))
invariant [ic3po_other15]	(forall P1, P2 . ((pc_p5(P2) & pc_p5(P1)) -> (ll(P1, P2) | unread(P1, P2))))
invariant [ic3po_other14]	(forall P1, P2 . ((pc_p6(P2) & pc_p5(P1)) -> (ll(P1, P2) | unread(P1, P2))))
invariant [ic3po_other23]	(forall P1, P2 . ((pc_p6(P2) & pc_p2(P1)) -> (unread(P1, P2) | le_number(num(P2), max(P1)) | unread(P2, P1))))
invariant [ic3po_other19]	(forall P1, P2 . ((pc_p3(P2) & pc_p6(P1)) -> (unread(P1, P2) | le_number(num(P1), max(P2)))))
invariant [ic3po_other12]	(forall P1, P2 . ((pc_p6(P1) & pc_p4(P2)) -> (ll(P1, P2) | unread(P1, P2))))
invariant [ic3po_other13]	(forall P1, P2 . ((pc_p6(P1) & pc_p5(P2)) -> (unread(P1, P2) | ll(P1, P2))))
invariant [ic3po_other16]	(forall P1, P2 . ((pc_p6(P1) & pc_p6(P2)) -> (unread(P1, P2) | ll(P1, P2))))
##
## similar invariants about a process being at "cs"
## cf. hand-written invariant:
## \A i \in P: pc[i] = "cs" => A j \in P \ {i} : After(j,i)
## The invariants generated by IC3PO match exactly the hand-written ones.
invariant [ic3po_other17]	(forall P1, P2 . ((pc_cs(P1) & pc_p2(P2)) -> (unread(P2, P1) | le_number(num(P1), max(P2)))))
invariant [ic3po_other8]	(forall P1, P2 . ((pc_p3(P2) & pc_cs(P1)) -> le_number(num(P1), max(P2))))
invariant [ic3po_other5]	(forall P1, P2 . ((pc_cs(P2) & pc_p4(P1)) -> ll(P2, P1)))
invariant [ic3po_other6]	(forall P1, P2 . ((pc_cs(P2) & pc_p5(P1)) -> ll(P2, P1)))
invariant [ic3po_other9]	(forall P1, P2 . ((pc_p5(P2) & pc_cs(P1)) -> unread(P2, P1)))
invariant [ic3po_other7]	(forall P1, P2 . ((pc_cs(P2) & pc_p6(P1)) -> ll(P2, P1)))
invariant [ic3po_other10]	(forall P1, P2 . ((pc_p6(P2) & pc_cs(P1)) -> unread(P2, P1)))
###

