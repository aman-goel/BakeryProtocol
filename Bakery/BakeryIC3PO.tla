----------------------------------- MODULE BakeryIC3PO ------------------------
(***************************************************************************)
(* This module defines a predicate that corresponds to the invariants      *)
(* generated by IC3PO for the Bakery protocol. We then use the TLA+ tools  *)
(* to check its soundness.                                                 *)
(***************************************************************************)
EXTENDS Bakery

MIInv(i) ==
  /\ pc[i] \in {"p4", "p5", "p6", "cs"} => num[i] # 0
  /\ pc[i] \in {"p2", "p3"} => flag[i]
  /\ pc[i] \in {"p5", "p6"} /\ flag[i] => \A j \in P \ {i} :
       /\ pc[j] \in {"p5", "p6"} => i \in unread[j]
       /\ pc[j] = "p6" => i # nxt[j]
       /\ pc[j] = "cs" => i = nxt[j] \/ j = nxt[j]
  /\ pc[i] \in {"p5", "p6"} => \A j \in P \ unread[i] :
       /\ pc[j] = "p2" => i \in unread[j] \/ max[j] >= num[i]
       /\ pc[j] = "p3" => max[j] >= num[i]
       /\ pc[j] \in {"p4", "p5", "p6"} => LL(i,j)
  /\ pc[i] = "p6" /\ pc[nxt[i]] = "p2" => i \in unread[nxt[i]] \/ max[nxt[i]] >= num[i]
  /\ pc[i] = "p6" /\ pc[nxt[i]] = "p3" /\ flag[nxt[i]] => max[nxt[i]] >= num[i]
  /\ pc[i] = "cs" => \A j \in P \ {i} :
       /\ pc[j] = "p2" => i \in unread[j] \/ max[j] >= num[i]
       /\ pc[j] = "p3" => max[j] >= num[i]
       /\ pc[j] = "p4" => LL(i,j)
       /\ pc[j] \in {"p5", "p6"} => LL(i,j) /\ i \in unread[j]
       /\ pc[j] # "cs"

MInv == \A i \in P : MIInv(i)

IndInv == TypeOK /\ MInv

THEOREM Spec => []MutualExclusion
<1>. USE N \in Nat DEFS P, ProcSet, IndInv, TypeOK, MInv
<1>1. Init => IndInv
  BY DEF Init, MIInv
<1>2. IndInv /\ [Next]_vars => IndInv'
  <2> SUFFICES ASSUME IndInv,
                      [Next]_vars
               PROVE  IndInv'
    OBVIOUS
  <2>1. ASSUME NEW self \in P,
               p1(self)
        PROVE  IndInv'
    <3>1. TypeOK'
      BY <2>1, Zenon DEF p1
    <3>2. ASSUME NEW i \in P PROVE MIInv(i)'
      BY <2>1, Z3T(60) DEF p1, MIInv, LL
    <3>. QED  BY <3>1, <3>2
  <2>2. ASSUME NEW self \in P,
               p2(self)
        PROVE  IndInv'
    BY <2>2, Z3T(60) DEF p2, MIInv, LL
  <2>3. ASSUME NEW self \in P,
               p3(self)
        PROVE  IndInv'
    BY <2>3, Z3T(60) DEF p3, MIInv, LL
  <2>4. ASSUME NEW self \in P,
               p4(self)
        PROVE  IndInv'
    <3>1. TypeOK'
      BY <2>4, Zenon DEF p4
    <3>2. ASSUME NEW i \in P PROVE MIInv(i)'
      BY <2>4, Z3T(10) DEF p4, MIInv, LL
    <3>. QED  BY <3>1, <3>2
  <2>5. ASSUME NEW self \in P,
               p5(self)
        PROVE  IndInv'
    BY <2>5, Z3T(60) DEF p5, MIInv, LL
  <2>6. ASSUME NEW self \in P,
               p6(self)
        PROVE  IndInv'
    BY <2>6 DEF p6, MIInv, LL
  <2>7. ASSUME NEW self \in P,
               cs(self)
        PROVE  IndInv'
    BY <2>7 DEF cs, MIInv, LL
  <2>8. ASSUME NEW self \in P,
               p7(self)
        PROVE  IndInv'
    BY <2>8, Z3T(60) DEF p7, MIInv, LL
  <2>9. CASE UNCHANGED vars
    BY <2>9 DEF vars, MIInv, LL
  <2>10. QED
    BY <2>1, <2>2, <2>3, <2>4, <2>5, <2>6, <2>7, <2>8, <2>9, Zenon DEF Next, p
<1>3. IndInv => MutualExclusion
  BY DEF IndInv, MIInv, MutualExclusion
<1>. QED  BY <1>1, <1>2, <1>3, PTL DEF Spec

===============================================================================